<html>
<head>
  <title>SEMS代码框架熟悉-入口函数(main)</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="986"/>
<h1>SEMS代码框架熟悉-入口函数(main)</h1>

<div>
<span><div>sems.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>int main(int argc, char* argv[])</div><div>{</div><div>    ...</div><div>    INFO(&quot;Starting application timer scheduler\n&quot;);</div><div>    <b>AmAppTimer::instance()-&gt;start(); //定时器线程，单例，继承关系为-&gt;_wheeltimer-&gt;AmThread</b></div><div><br/></div><div>    INFO(&quot;Starting session container\n&quot;);</div><div>    <b>AmSessionContainer::instance()-&gt;start(); //Session容器线程，全局唯一，继承关系为-&gt;AmThread</b></div><div><br/></div><div>#ifdef SESSION_THREADPOOL</div><div>    INFO(&quot;Starting session processor threads\n&quot;);</div><div>    <b>AmSessionProcessor::addThreads(AmConfig::SessionProcessorThreads); //如果定义了线程池宏，静态顶层类，则初始化线程池中线程数量，可配置</b></div><div>#endif</div><div><br/></div><div>    INFO(&quot;Starting media processor\n&quot;);</div><div>    <b>AmMediaProcessor::instance()-&gt;init(); //媒体处理类，全局唯一，顶层类，初始化函数为根据配置创建媒体处理线程并启动它（们），默认为创建1个</b></div><div><br/></div><div>    // init thread usage with libevent</div><div>    // before it's too late</div><div>    <b>if(evthread_use_pthreads() != 0) { //启动libevent线程</b></div><div>        ERROR(&quot;cannot init thread usage with libevent&quot;);</div><div>        goto error;</div><div>    }</div><div><br/></div><div>    // start the asynchronous file writer (sorry, no better place...)</div><div>    <b>async_file_writer::instance()-&gt;start(); //异步写文件线程，单例，继承关系为-&gt;AmThread</b></div><div><br/></div><div>    INFO(&quot;Starting RTP receiver\n&quot;);</div><div>    <b>AmRtpReceiver::instance()-&gt;start(); //启动RTP接收线程，单例，顶层类，但包含一个RTP接收线程的数组，数量可配置，在构造函数中创建所有线程，start函数启动它（们）</b></div><div><br/></div><div>    INFO(&quot;Starting SIP stack (control interface)\n&quot;);</div><div>    if(SipCtrlInterface::instance()-&gt;load()) {</div><div>        goto error;</div><div>    }</div><div><br/></div><div>    INFO(&quot;Loading plug-ins\n&quot;);</div><div>    AmPlugIn::instance()-&gt;init();</div><div>    if(AmPlugIn::instance()-&gt;load(AmConfig::PlugInPath, AmConfig::LoadPlugins))</div><div>        goto error;</div><div><br/></div><div>    AmPlugIn::instance()-&gt;registerLoggingPlugins();</div><div><br/></div><div>    AmSessionContainer::instance()-&gt;initMonitoring();</div><div><br/></div><div>#ifndef DISABLE_DAEMON_MODE</div><div>    if(fd[1]) {</div><div>        DBG(&quot;hi world! I'm main child [%d]\n&quot;, main_pid);</div><div>        (void)write(fd[1], &amp;main_pid, sizeof(int));</div><div>        close(fd[1]); fd[1] = 0;</div><div>    }</div><div>#endif</div><div><br/></div><div>    INFO(&quot;SEMS &quot; SEMS_VERSION &quot; (&quot; ARCH &quot;/&quot; OS&quot;) started&quot;);</div><div><br/></div><div>    // running the server</div><div>    <b>if(SipCtrlInterface::instance()-&gt;run() != -1) //启动UDP和TCP线程，线程数量可配置，单例，继承关系为-&gt;sip_ua</b></div><div>        success = true;</div><div>    ...</div><div>}</div></div><div style="text-align: center"> |</div><div style="text-align: center"> |</div><div style="text-align: center"> V</div><div>SipCtrlInterface.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>01 int _SipCtrlInterface::run()</div><div>02 {</div><div>03     wheeltimer::instance()-&gt;start();</div><div>04</div><div>05     if(NULL != udp_servers) {</div><div>06         for(int i=0; i&lt;nr_udp_servers; i++) {</div><div>07             <span style="color: rgb(45, 79, 201);"><b>udp_servers[i]-&gt;start(); //UDP传输线程，继承关系为udp_trsp-&gt;transport-&gt;AmThread。start函数是从AmThread继承过来的函数，其功能是创建线程，并执行run函数</b></span></div><div>08         }</div><div>09     }</div><div>10</div><div>11     if(NULL != tcp_servers) {</div><div>12         for(int i=0; i&lt;nr_tcp_servers; i++) {</div><div>13             tcp_servers[i]-&gt;start();</div><div>14         }</div><div>15     }</div><div>16</div><div>17     while(!stopped.get()) {</div><div>18         stopped.wait_for();</div><div>19     }</div><div>20</div><div>21     return 0;    </div><div>22 }</div></div><div style="text-align: center"> |</div><div style="text-align: center"> |</div><div style="text-align: center"> V</div><div>udp_trsp.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void udp_trsp::run()</div><div>{</div><div>    ...</div><div>    while(true){</div><div><br/></div><div>        //DBG(&quot;before recvmsg (%s:%i)\n&quot;,sock-&gt;get_ip(),sock-&gt;get_port());</div><div><br/></div><div>        <span style="color: rgb(45, 79, 201);"><b>buf_len = recvmsg(sock-&gt;get_sd(),&amp;msg,0); //调用系统函数接收网络数据</b></span></div><div>        if(buf_len &lt;= 0){</div><div>            if(!buf_len) continue;</div><div>            ERROR(&quot;recvfrom returned %d: %s\n&quot;,buf_len,strerror(errno));</div><div>            switch(errno){</div><div>            case EBADF:</div><div>            case ENOTSOCK:</div><div>            case EOPNOTSUPP:</div><div>                return;</div><div>            }</div><div>            continue;</div><div>        }</div><div><br/></div><div>        if(buf_len &gt; MAX_UDP_MSGLEN){</div><div>            ERROR(&quot;Message was too big (&gt;%d)\n&quot;,MAX_UDP_MSGLEN);</div><div>            continue;</div><div>        }</div><div><br/></div><div>        sockaddr_storage* sa = (sockaddr_storage*)msg.msg_name;</div><div>        if(!am_get_port(sa)) {</div><div>            DBG(&quot;Source port is 0: dropping&quot;);</div><div>            continue;</div><div>        }</div><div><br/></div><div>        sip_msg* s_msg = new sip_msg(buf,buf_len);</div><div>        memcpy(&amp;s_msg-&gt;remote_ip,msg.msg_name,msg.msg_namelen);</div><div><br/></div><div>        ...</div><div><br/></div><div>        s_msg-&gt;local_socket = sock;</div><div>        inc_ref(sock);</div><div><br/></div><div>        for (cmsgptr = CMSG_FIRSTHDR(&amp;msg);  cmsgptr != NULL;  cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) {</div><div>            if (cmsgptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp;  cmsgptr-&gt;cmsg_type == DSTADDR_SOCKOPT) {</div><div>                s_msg-&gt;local_ip.ss_family = AF_INET;</div><div>                am_set_port(&amp;s_msg-&gt;local_ip,sock-&gt;get_port());</div><div>                memcpy(&amp;((sockaddr_in*)(&amp;s_msg-&gt;local_ip))-&gt;sin_addr,</div><div>                dstaddr(cmsgptr),sizeof(in_addr));</div><div>            }  else if(cmsgptr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;  cmsgptr-&gt;cmsg_type == IPV6_PKTINFO) {</div><div>                s_msg-&gt;local_ip.ss_family = AF_INET6;</div><div>                am_set_port(&amp;s_msg-&gt;local_ip,sock-&gt;get_port());</div><div>                memcpy(&amp;((sockaddr_in6*)(&amp;s_msg-&gt;local_ip))-&gt;sin6_addr,</div><div>                dstaddr6(cmsgptr),sizeof(in6_addr));</div><div>            }</div><div>        }</div><div><br/></div><div>        // pass message to the parser / transaction layer</div><div>        <span style="color: rgb(45, 79, 201);"><b>trans_layer::instance()-&gt;received_msg(s_msg); //接收消息，将其传递给trans_layer处理，单例，顶层类。该函数的功能是：对消息做判断，并最终调用该类的process_rcvd_msg函数</b></span></div><div>    }</div><div>}</div></div><div style="text-align: center"> |</div><div style="text-align: center"> |</div><div style="text-align: center"> V</div><div>trans_layer.cpp（以INVITE消息为例）</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void _trans_ayer::process_rcvd_msg(sip_msg* msg)</div><div>{</div><div>...</div><div>                    default:</div><div>                        // New transaction</div><div>                         t = bucket-&gt;add_trans(msg, TT_UAS);</div><div><br/></div><div>                         bucket-&gt;unlock();</div><div><br/></div><div>                         //  let's pass the request to</div><div>                         //  the UA.</div><div>                         assert(ua);</div><div>                         <span style="color: rgb(45, 79, 201);"><b>ua-&gt;handle_sip_request(trans_ticket(t,bucket),msg); //调用SipCtrlInterface的handle_sip_request接口。SipCtrlInterface变量是通过register_ua在SipCtrlInterface构造函数中传递进来的。</b></span></div><div><br/></div><div>                         // forget the msg: it will be</div><div>                         // owned by the new transaction</div><div>                         return;</div><div>...</div><div>}</div></div><div style="text-align: center"> |</div><div style="text-align: center"> |</div><div style="text-align: center"> V</div><div>SipCtrlInterface.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void _SipCtrlInterface::handle_sip_request(const trans_ticket&amp; tt, sip_msg* msg)</div><div>{</div><div>    ...</div><div>    <span style="color: rgb(45, 79, 201);"><b>AmSipDispatcher::instance()-&gt;handleSipMsg(req); //处理SIP请求。全局唯一，顶层类</b></span></div><div><br/></div><div>    DBG(&quot;^^ M [%s|%s] Ru SIP request %s handled ^^\n&quot;,</div><div>    req.callid.c_str(), req.to_tag.c_str(), req.method.c_str());</div><div>}</div></div><div style="text-align: center"> |</div><div style="text-align: center"> |</div><div style="text-align: center"> V</div><div>AmSipDispatcher.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmSipDispatcher::handleSipMsg(AmSipRequest &amp;req)</div><div>{</div><div>    ...</div><div>    DBG(&quot;method: `%s' [%zd].\n&quot;, req.method.c_str(), req.method.length());</div><div>    if(req.method == SIP_METH_INVITE){</div><div><br/></div><div>        <span style="color: rgb(45, 79, 201);"><b>AmSessionContainer::instance()-&gt;startSessionUAS(req); //创建一个服务器session，把它添加的AmEventDispatcher中，并启动它</b></span></div><div>    }</div><div>    ...</div><div>}</div><div><br/></div></div><div style="text-align: center"> |</div><div style="text-align: center"> |</div><div style="text-align: center"> V</div><div>AmSessionContainer.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmSessionContainer::startSessionUAS(AmSipRequest&amp; req)</div><div>{</div><div>    ...</div><div>    // Call-ID and From-Tag are unknown: it's a new session</div><div>    auto_ptr&lt;AmSession&gt; session;</div><div>    string app_name;</div><div><br/></div><div>    <span style="color: rgb(45, 79, 201);"><b>session.reset(createSession(req,app_name)); //创建session，使用对象工厂模式创建，最终在onInvite中新建一个session对象</b></span></div><div>    if(session.get() != 0){</div><div><br/></div><div>        // update session's local tag (ID) if not already set</div><div>        session-&gt;setLocalTag();</div><div>        const string&amp; local_tag = session-&gt;getLocalTag();</div><div>        // by default each session is in its own callgroup</div><div>        session-&gt;setCallgroup(local_tag);</div><div><br/></div><div>        if (AmConfig::LogSessions) {</div><div>          INFO(&quot;Starting UAS session %s\n&quot;,  local_tag.c_str());</div><div>        }</div><div><br/></div><div>        switch(<span style="color: rgb(45, 79, 201);"><b>addSession(req.callid,req.from_tag,local_tag, req.via_branch,session.get())</b></span>) { <span style="color: rgb(45, 79, 201);"><b>//将session添加到AmEventDispatcher中。AmEventDispatcher是一个全局唯一的顶层类，用来管理所有会话中产生的事件的分发</b></span></div><div><br/></div><div>        case AmSessionContainer::Inserted:</div><div>            // successful case</div><div>            break;</div><div><br/></div><div>        case AmSessionContainer::ShutDown:</div><div>            throw AmSession::Exception(AmConfig::ShutdownModeErrCode,</div><div>                     AmConfig::ShutdownModeErrReason);</div><div><br/></div><div>        case AmSessionContainer::AlreadyExist:</div><div>            throw AmSession::Exception(482,</div><div>                     SIP_REPLY_LOOP_DETECTED);</div><div><br/></div><div>        default:</div><div>            ERROR(&quot;adding session to session container\n&quot;);</div><div>            throw string(SIP_REPLY_SERVER_INTERNAL_ERROR);</div><div>        }</div><div><br/></div><div>        MONITORING_LOG4(local_tag.c_str(),</div><div>            &quot;dir&quot;, &quot;in&quot;,</div><div>            &quot;from&quot;, req.from.c_str(),</div><div>            &quot;to&quot;, req.to.c_str(),</div><div>            &quot;ruri&quot;, req.r_uri.c_str());</div><div><br/></div><div>        try {</div><div>            <span style="color: rgb(45, 79, 201);"><b>session-&gt;start(); //启动session，根据是否定义线程池宏来决定是新建线程还是获取线程</b></span></div><div>        } catch (...) {</div><div>            AmEventDispatcher::instance()-&gt; delEventQueue(local_tag);</div><div>            throw;</div><div>        }</div><div><br/></div><div>        <span style="color: rgb(45, 79, 201);"><b>session-&gt;postEvent(new AmSipRequestEvent(req)); //postEvent继承自AmEventQueue-&gt;AmEventQueueInterface。</b></span></div><div>        session.release();</div><div>    }</div><div>    ...</div><div>}</div><div><br/></div></div><div style="text-align: center"> |</div><div style="text-align: center"> |</div><div style="text-align: center"> V</div><div>AmEventQueue.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmEventQueue::postEvent(AmEvent* event)</div><div>{</div><div>    if (AmConfig::LogEvents)</div><div>        DBG(&quot;AmEventQueue: trying to post event\n&quot;);</div><div><br/></div><div>    m_queue.lock();</div><div><br/></div><div>    if(event)</div><div>        <span style="color: rgb(45, 79, 201);"><b>ev_queue.push(event); //添加到队列</b></span></div><div><br/></div><div>    if(!ev_pending.get()) {</div><div>        ev_pending.set(true);</div><div>        if (NULL != wakeup_handler)</div><div>            <span style="color: rgb(45, 79, 201);"><b>wakeup_handler-&gt;notify(this); //唤醒线程处理。至此，消息转由另外一个线程处理</b></span></div><div>    }</div><div><br/></div><div>    m_queue.unlock();</div><div><br/></div><div>    if (AmConfig::LogEvents)</div><div>        DBG(&quot;AmEventQueue: event posted\n&quot;);</div><div>}</div></div><div style="text-align: center"> |</div><div style="text-align: center"> |</div><div style="text-align: center"> V</div><div>AmEventQueue.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmEventQueue::processEvents()</div><div>{</div><div>    m_queue.lock();</div><div><br/></div><div>    while(!ev_queue.empty()) {</div><div><br/></div><div>        AmEvent* event = ev_queue.front();</div><div>        ev_queue.pop();</div><div>        m_queue.unlock();</div><div><br/></div><div>        if (AmConfig::LogEvents)</div><div>            DBG(&quot;before processing event (%s)\n&quot;,</div><div>        typeid(*event).name());</div><div>        <span style="color: rgb(45, 79, 201);"><b>handler-&gt;process(event); //处理队列中的事件，在另一个线程中</b></span></div><div>        if (AmConfig::LogEvents)</div><div>            DBG(&quot;event processed (%s)\n&quot;,</div><div>        typeid(*event).name());</div><div>        delete event;</div><div>        m_queue.lock();</div><div>    }</div><div><br/></div><div>    ev_pending.set(false);</div><div>    m_queue.unlock();</div><div>}</div><div><br/></div></div><div><br/></div></span>
</div></body></html> 