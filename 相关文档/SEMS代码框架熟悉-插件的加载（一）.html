<html>
<head>
  <title>SEMS代码框架熟悉-插件的加载（一）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1238"/>
<h1>SEMS代码框架熟悉-插件的加载（一）</h1>

<div>
<span><div><span style="font-size: 16px;"><b>插件实例的初始化</b></span></div><hr/><div>插件实例是一个全局单例，它的初始化时在程序的main函数中被调用的，main函数在sems.cpp中，代码如下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);">int main(int argc, char* argv[])</span></div><div><span style="color: rgb(51, 51, 51);">{</span></div><div><span style="color: rgb(51, 51, 51);">...</span></div><div><span style="color: rgb(51, 51, 51);">    INFO(&quot;Loading plug-ins\n&quot;);</span></div><div><span style="color: rgb(51, 51, 51);">   </span> <span style="color: rgb(255, 0, 0);"><b>AmPlugIn::instance()-&gt;init();</b></span></div><div><span style="color: rgb(51, 51, 51);">    if(</span>AmPlugIn::instance()-&gt;load(AmConfig::PlugInPath, AmConfig::LoadPlugins)<span style="color: rgb(51, 51, 51);">)</span></div><div><span style="color: rgb(51, 51, 51);">        goto error;</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">    AmPlugIn::instance()-&gt;registerLoggingPlugins();</span></div><div><span style="color: rgb(51, 51, 51);">...</span></div><div><span style="color: rgb(51, 51, 51);">}</span></div></div><div>插件实例的初始化主要做了以下几个事情：</div><ul><li>读取配置文件中禁用的payload参数（<span style="color: rgb(28, 51, 135);"><b>对应sems.conf配置文件中的exclude_payloads参数</b></span>）。解析这个参数对应的值，并将解析出来的结果保存在一个字符串set中，提供给后续使用，这个set变量的名称是：<span style="color: rgb(123, 0, 61);"><b>std::set&lt;string&gt; excluded_payloads</b></span>;</li><li>添加内置的codec到成员变量<span style="color: rgb(123, 0, 61);"><b>std::map&lt;int,amci_codec_t*&gt; codecs</b></span>中，这个map以codec的内置id作为key（所有codec的id被定义在文件codecs.h中），acmi_codec_t的声明如下：</li></ul><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div style="margin-left:40px;">struct amci_codec_t {</div><div style="margin-left:40px;">    int id;                       //codec内置id</div><div style="margin-left:40px;">    amci_converter_t encode;      //将输入缓存（格式为pcm16）编码为指定的格式的编码函数</div><div style="margin-left:40px;">    amci_converter_t decode;      //解码函数</div><div style="margin-left:40px;">    amci_plc_t plc;               //丢包补偿函数</div><div style="margin-left:40px;">    amci_codec_init_t init;       //codec初始化函数</div><div style="margin-left:40px;">    amci_codec_destroy_t destroy; //codec销毁函数</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">    amci_codec_bytes2samples_t bytes2samples; //计算指定字节数包含多少个采样点</div><div style="margin-left:40px;">    amci_codec_samples2bytes_t samples2bytes; //计算指定采样定包含多少个字节</div><div style="margin-left:40px;">};</div></div><ul><li>添加内置的payload到成员变量<span style="color: rgb(123, 0, 61);"><b>std::map&lt;int,amci_payload_t*&gt; payloads</b></span>中，这个map以payload的id作为key，amci_payload_t的声明如下：</li></ul><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div style="margin-left:40px;">struct amci_payload_t {</div><div style="margin-left:40px;">    int   payload_id; //payload id，其取值遵循RFC 1890</div><div style="margin-left:40px;">    const char* name; //payload 名称，其取值遵循RFC 1890。常见的例如：PCMA，PCMU</div><div style="margin-left:40px;">    int sample_rate;  //采样频率，即每秒多少个采用点</div><div style="margin-left:40px;">    <span style="color: rgb(255, 0, 0);">/**</span></div><div style="margin-left:40px;"><span style="color: rgb(255, 0, 0);">     * Sample rate that is advertised in SDP.</span></div><div style="margin-left:40px;"><span style="color: rgb(255, 0, 0);">     * example: g722 has advertised_sample_rate 8000, and sample_rate 16000.</span></div><div style="margin-left:40px;"><span style="color: rgb(255, 0, 0);">     */</span></div><div style="margin-left:40px;"><span style="color: rgb(255, 0, 0);">   </span> <b><span style="color: rgb(255, 0, 0);">int advertised_sample_rate;</span></b></div><div style="margin-left:40px;">    int channels;     //声道数，1表示单声道，2表示双声道</div><div style="margin-left:40px;">    int codec_id;     //对应的内置codec id</div><div style="margin-left:40px;">    <span style="color: rgb(255, 0, 0);">/** @see AMCI_PT_AUDIO_LINEAR, AMCI_PT_AUDIO_FRAME */</span></div><div style="margin-left:40px;"><span style="color: rgb(255, 0, 0);">    <b>int type;</b></span></div><div style="margin-left:40px;">};</div></div><div>需要注意的是：加载payload时，如果这个payload对应的codec没有加载，那么payload也无法被加载。另外，如果在配置文件中设置了codec的顺序（<span style="color: rgb(28, 51, 135);"><b>对应sems.conf配置文件中的codec_order字段</b></span>），那么payload也会按顺序插入到成员变量<span style="color: rgb(123, 0, 61);"><b>std::multimap&lt;int,int&gt; payload_order</b></span>中。</div><div><br/></div><div><span style="font-size: 16px;"><b>插件的加载</b></span></div><hr/><div>代码调用顺序：</div><div>[<span style="color: rgb(173, 0, 0);">sems.cpp</span>] AmPlugIn::instance()-&gt;load(AmConfig::PlugInPath, AmConfig::LoadPlugins)</div><div>[<span style="color: rgb(173, 0, 0);">AmPlugIn.cpp</span>] int AmPlugIn::load(const string&amp; directory, const string&amp; plugins)</div><div>[<span style="color: rgb(173, 0, 0);">AmPlugIn.cpp</span>] int AmPlugIn::loadPlugIn(const string&amp; file, const string&amp; plugin_name,  vector&lt;AmPluginFactory*&gt;&amp; plugins)</div><div>插件加载的核心在于loadPlugIn函数的处理，它使用dlopen，dlsym的方式动态的加载.so库。通过查找动态库是否导出了指定名称的函数来判断插件是否标准或具备某项功能。对于一个插件的导出函数，它的查找步骤为：</div><ul><li><b>amci_exports_t* exports = (amci_exports_t*)dlsym(h_dl,&quot;amci_exports&quot;) -</b> 查找动态库是否导出了acmi_exports结构，该结构是插件具有媒体编解码处理能力。acmi_export_t的声明为：</li></ul><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div style="margin-left:40px;">struct amci_exports_t {</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">    /** Module name */</div><div style="margin-left:40px;">    char* name;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">    /** Codec module load function. can be NULL */</div><div style="margin-left:40px;">    amci_codec_module_load_t module_load;</div><div style="margin-left:40px;">    /** Codec module destroy function. can be NULL */</div><div style="margin-left:40px;">    amci_codec_module_destroy_t module_destroy;</div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">    /** NULL terminated array of amci_codec_t */</div><div style="margin-left:40px;">    struct amci_codec_t*    codecs;       </div><div style="margin-left:40px;">    /** NULL terminated array of amci_payload_t */</div><div style="margin-left:40px;">    struct amci_payload_t*  payloads;     </div><div style="margin-left:40px;">    /** NULL terminated array of amci_inoutfmt_t */</div><div style="margin-left:40px;">    struct amci_inoutfmt_t* file_formats;</div><div style="margin-left:40px;">};</div></div><div style="margin-left:40px;">SEMS中导出了这个结构的插件有：adpcm.so，g722.so，g729.so，gsm.so，ilbc.so，isac.so，l16.so，mp3.so，opus.so，silk.so，speex.so，wav.so。</div><div style="margin-left:40px;">如果这个插件被识别为具有媒体处理能力，那么该插件中的所有codec，payload和file format将会被添加到相应的set中。</div><div style="margin-left:40px;"><br/></div><ul><li><b>FactoryCreate fc = (FactoryCreate)dlsym(h_dl,FACTORY_SESSION_EXPORT_STR)</b> <b>-</b> 查找动态库是否导出“session_factory_create”符号。导出了该函数的插件具有创建session的能力。导出的方式是插件中的类继承自AmSessionFactory类。具有“session_factory_create ”导出符号的插件具有如下关系的类图：</li></ul><div style="text-align: center">          <img src="SEMS代码框架熟悉-插件的加载（一）_files/Image.png" type="image/png" style="height: auto;"/></div><div>          SEMS中导出了这个结构的插件有：announce_auth.so，ann_b2b.so，announcement.so，announce_transfer.so，annrecorder.so，voicemail.so，sbc.so，dsm.so等等。</div><div>          具有“session_factory_create ”能力的插件就是SEMS的一个app，它有一个名称，并且有一个独立的配置文件用来配置这个app的全局配置，例如etc/sbc.conf，etc/dsm.conf等。</div><div>          如果插件具有这个能力，那么紧接着SEMS就会对该插件进行加载，加载的步骤为（实现代码包含在<span style="color: rgb(123, 0, 61);"><b>int AmPlugIn::loadAppPlugIn(AmPluginFactory* f)</b></span>中）：</div><ul><li style="display:inline;list-style:none;"><ul><li>查找插件是否已经加载，即成员变量name2app中是否包含该插件。name2app的声明为std::map&lt;string,AmSessionFactory*&gt; name2app，他是一个map，以app名称为key；</li><li>如果未找到，则将该插件添加到name2app变量中；</li><li>将插件添加到module_objects变量中。<span style="color: rgb(255, 0, 0);"><b>（module_objects的原型与name2app一样，暂时不太明白为什么用定义两个内容一样的变量。）</b></span></li></ul></li></ul><div><b><span style="color: rgb(255, 0, 0);"><br/></span></b></div><ul><li><b>FactoryCreate fc = (FactoryCreate)dlsym(h_dl,FACTORY_SESSION_EVENT_HANDLER_EXPORT_STR)</b> <b>-</b> 查找动态库是否导出“sess_evh_factory_create”符号。导出了该函数的插件具有处理session事件的能力。导出的方式是插件中的类继承自AmSessionEventHandlerFactory类，具有如下关系类图：</li></ul><div style="text-align: center">     <img src="SEMS代码框架熟悉-插件的加载（一）_files/Image [1].png" type="image/png"/></div><div>          SEMS中导出了这个结构的插件有：session_time.so</div><div>          具有这个能力的插件被保存在变量name2seh中。</div><div><br/></div><ul><li><b>FactoryCreate fc = (FactoryCreate)dlsym(h_dl,FACTORY_PLUGIN_CLASS_EXPORT_STR)</b> <b>-</b> 查找动态库是否有继承自AmDynInvokeFactory的类，继承自这个类的插件具有invoke能力，插件被保存在name2di变量中</li></ul><div>     <span style="color: rgb(255, 0, 0);"><b>NOTE：一个插件可以具有多种能力。</b></span></div><div><br/></div><div><span style="font-size: 16px;"><b>插件的初始化</b></span></div><div><hr/></div><div>在通过dlopen，dlsym调用成功的插件，会保存在一个数组中，然后循环调用每个插件的onLoad函数，然后由每个插件的onLoad完成自己的初始化。具体代码在：</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>int AmPlugIn::load(const string&amp; directory, const string&amp; plugins)</div><div>{</div><div> ...</div><div>  DBG(&quot;AmPlugIn: modules loaded.\n&quot;);</div><div>  DBG(&quot;Initializing %zd plugins...\n&quot;, loaded_plugins.size());</div><div>  for (vector&lt;AmPluginFactory*&gt;::iterator it =</div><div>     loaded_plugins.begin(); it != loaded_plugins.end(); it++) {</div><div>    <span style="color: rgb(255, 0, 0);"><b>int err = (*it)-&gt;onLoad();</b></span></div><div>    if(err)</div><div>      return err;</div><div>  }</div><div><br/></div><div>  return 0;</div><div>}</div></div><div><br/></div></span>
</div></body></html> 