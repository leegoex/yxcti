<html>
<head>
  <title>SEMS代码框架熟悉-媒体流处理(接收)</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1252"/>
<h1>SEMS代码框架熟悉-媒体流处理(接收)</h1>

<div>
<span><div>NOTE：一个AmSession只是处理1个CallLeg的RTP流，如果一个通话有多个CallLeg，则需要多个AmSession或其派生类处理。</div><div><br/></div><div>AmSession.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>int AmSession::onSdpCompleted(const AmSdp&amp; local_sdp, const AmSdp&amp; remote_sdp)</div><div>{</div><div>  DBG(&quot;AmSession::onSdpCompleted(...) ...\n&quot;);</div><div><br/></div><div>  if(local_sdp.media.empty() || remote_sdp.media.empty()) {</div><div><br/></div><div>    ERROR(&quot;Invalid SDP&quot;);</div><div><br/></div><div>    string debug_str;</div><div>    local_sdp.print(debug_str);</div><div>    ERROR(&quot;Local SDP:\n%s&quot;,</div><div>      debug_str.empty() ? &quot;&lt;empty&gt;&quot;</div><div>      : debug_str.c_str());</div><div><br/></div><div>    remote_sdp.print(debug_str);</div><div>    ERROR(&quot;Remote SDP:\n%s&quot;,</div><div>      debug_str.empty() ? &quot;&lt;empty&gt;&quot;</div><div>      : debug_str.c_str());</div><div><br/></div><div>    return -1;</div><div>  }</div><div><br/></div><div>  bool set_on_hold = false;</div><div>  if (!remote_sdp.media.empty()) {</div><div>    vector&lt;SdpAttribute&gt;::const_iterator pos =</div><div>      std::find(remote_sdp.media[0].attributes.begin(), remote_sdp.media[0].attributes.end(), SdpAttribute(&quot;sendonly&quot;));</div><div>    set_on_hold = pos != remote_sdp.media[0].attributes.end();</div><div>  }</div><div><br/></div><div>  lockAudio();</div><div><br/></div><div>  // TODO:</div><div>  //   - get the right media ID</div><div>  //   - check if the stream coresponding to the media ID</div><div>  //     should be created or updated   </div><div>  //</div><div>  int ret = 0;</div><div><br/></div><div>  try {</div><div>    ret = <span style="color: rgb(255, 0, 0);"><b>RTPStream()-&gt;init(local_sdp, remote_sdp, AmConfig::ForceSymmetricRtp); //触发调用AmRtpStream::setLocalPort，并最终启动RTP接收</b></span></div><div>  } catch (const string&amp; s) {</div><div>    ERROR(&quot;Error while initializing RTP stream: '%s'\n&quot;, s.c_str());</div><div>    ret = -1;</div><div>  } catch (...) {</div><div>    ERROR(&quot;Error while initializing RTP stream (unknown exception in AmRTPStream::init)\n&quot;);</div><div>    ret = -1;</div><div>  }</div><div>  unlockAudio();</div><div><br/></div><div>  if (!isProcessingMedia()) {</div><div>    setInbandDetector(AmConfig::DefaultDTMFDetector);</div><div>  }</div><div><br/></div><div>  return ret;</div><div>}</div></div><div><br/></div><div>AmRtpStream.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmRtpStream::setLocalPort(unsigned short p)</div><div>{</div><div>  if(l_port)</div><div>    return;</div><div><br/></div><div>  if(l_if &lt; 0) {</div><div>    if (session) l_if = session-&gt;getRtpInterface();</div><div>    else {</div><div>      ERROR(&quot;BUG: no session when initializing RTP stream, invalid interface can be used\n&quot;);</div><div>      l_if = 0;</div><div>    }</div><div>  }</div><div><br/></div><div>  int retry = 10;</div><div>  unsigned short port = 0;</div><div>  for(;retry; --retry){</div><div><br/></div><div>    if (!getLocalSocket())</div><div>      return;</div><div><br/></div><div>    if(!p)</div><div>      port = AmConfig::RTP_Ifs[l_if].getNextRtpPort();</div><div>    else</div><div>      port = p;</div><div><br/></div><div>    am_set_port(&amp;l_saddr,port+1);</div><div>    if(bind(l_rtcp_sd,(const struct sockaddr*)&amp;l_saddr,SA_len(&amp;l_saddr))) {</div><div>      DBG(&quot;bind: %s\n&quot;,strerror(errno));       </div><div>      goto try_another_port;</div><div>    }</div><div><br/></div><div>    am_set_port(&amp;l_saddr,port);</div><div>    if(bind(l_sd,(const struct sockaddr*)&amp;l_saddr,SA_len(&amp;l_saddr))) {</div><div>      DBG(&quot;bind: %s\n&quot;,strerror(errno));       </div><div>      goto try_another_port;</div><div>    }</div><div><br/></div><div>    // both bind() succeeded!</div><div>    break;</div><div><br/></div><div>  try_another_port:</div><div>      close(l_sd);</div><div>      l_sd = 0;</div><div>      close(l_rtcp_sd);</div><div>      l_rtcp_sd = 0;</div><div>  }</div><div><br/></div><div>  int true_opt = 1;</div><div>  if (!retry){</div><div>    ERROR(&quot;could not find a free RTP port\n&quot;);</div><div>    throw string(&quot;could not find a free RTP port&quot;);</div><div>  }</div><div><br/></div><div>  // rco: does that make sense after bind() ????</div><div>  if(setsockopt(l_sd, SOL_SOCKET, SO_REUSEADDR,</div><div>        (void*)&amp;true_opt, sizeof (true_opt)) == -1) {</div><div><br/></div><div>    ERROR(&quot;%s\n&quot;,strerror(errno));</div><div>    close(l_sd);</div><div>    l_sd = 0;</div><div>    throw string (&quot;while setting local address reusable.&quot;);</div><div>  }</div><div><br/></div><div>  l_port = port;</div><div>  l_rtcp_port = port+1;</div><div><br/></div><div>  if(!p) {</div><div>    <span style="color: rgb(255, 0, 0);"><b>AmRtpReceiver::instance()-&gt;addStream(l_sd, this); //从网络接收RTP包，并缓存</b></span></div><div>    <span style="color: rgb(255, 0, 0);"><b>AmRtpReceiver::instance()-&gt;addStream(l_rtcp_sd, this); //从网络接收RTCP包，并缓存</b></span></div><div>    DBG(&quot;added stream [%p] to RTP receiver (%s:%i/%i)\n&quot;, this,</div><div>    get_addr_str((sockaddr_storage*)&amp;l_saddr).c_str(),l_port,l_rtcp_port);</div><div>  }</div><div><br/></div><div>  memcpy(&amp;l_rtcp_saddr, &amp;l_saddr, sizeof(l_saddr));</div><div>  am_set_port(&amp;l_rtcp_saddr, l_rtcp_port);</div><div>}</div></div><div><br/></div><div>AmRtpReceiver.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmRtpReceiverThread::_rtp_receiver_read_cb(evutil_socket_t sd,</div><div>                        short what, void* arg)</div><div>{</div><div>  AmRtpReceiverThread::StreamInfo* p_si =</div><div>    static_cast&lt;AmRtpReceiverThread::StreamInfo*&gt;(arg);</div><div><br/></div><div>  p_si-&gt;thread-&gt;streams_mut.lock();</div><div>  if(!p_si-&gt;stream) {</div><div>    // we are about to get removed...</div><div>    p_si-&gt;thread-&gt;streams_mut.unlock();</div><div>    return;</div><div>  }</div><div>  <span style="color: rgb(255, 0, 0);"><b>p_si-&gt;stream-&gt;recvPacket(sd); //接收数据并缓存</b></span></div><div>  p_si-&gt;thread-&gt;streams_mut.unlock();</div><div>}</div></div><div><br/></div><div>AmRtpStream.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmRtpStream::recvPacket(int fd)</div><div>{</div><div>  if(fd == l_rtcp_sd){</div><div>    recvRtcpPacket();</div><div>    return;</div><div>  }</div><div><br/></div><div>  AmRtpPacket* p = mem.newPacket();</div><div>  if (!p) p = reuseBufferedPacket();</div><div>  if (!p) {</div><div>    DBG(&quot;out of buffers for RTP packets, dropping (stream [%p])\n&quot;,</div><div>    this);</div><div>    // drop received data</div><div>    AmRtpPacket dummy;</div><div>    dummy.recv(l_sd);</div><div>    return;</div><div>  }</div><div><br/></div><div>  <span style="color: rgb(255, 0, 0);"><b>if(p-&gt;recv(l_sd) &gt; 0){ //接收网络包，保存在一个AmRtpPacket对象p中</b></span></div><div>    int parse_res = 0;</div><div><br/></div><div>    if (logger) p-&gt;logReceived(logger, &amp;l_saddr);</div><div><br/></div><div>    gettimeofday(&amp;p-&gt;recv_time,NULL);</div><div><br/></div><div>    if(!relay_raw</div><div>#ifdef WITH_ZRTP</div><div>       &amp;&amp; !(session &amp;&amp; session-&gt;enable_zrtp)</div><div>#endif</div><div>       ) {</div><div>      parse_res = p-&gt;parse();</div><div>    }</div><div><br/></div><div>    if (parse_res == -1) {</div><div>      DBG(&quot;error while parsing RTP packet.\n&quot;);</div><div>      clearRTPTimeout(&amp;p-&gt;recv_time);</div><div>      mem.freePacket(p);     </div><div>    } else {</div><div>      <span style="color: rgb(255, 0, 0);"><b>bufferPacket(p); //缓存RTP包到rtp_ev_queue中</b></span></div><div>    }</div><div>  } else {</div><div>    mem.freePacket(p);</div><div>  }</div><div>}</div></div><div>以上代码为从网络接收RTP包，并缓存到AmRtpStream中的代码流程。</div><div>下面介绍处理RTP的代码流程。</div><div><br/></div><div><hr/></div><div><br/></div><div>AmSession.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmSession::startMediaProcessing()</div><div>{</div><div>  if(getStopped() || isProcessingMedia())</div><div>    return;</div><div><br/></div><div>  if(isAudioSet()) {</div><div>    <span style="color: rgb(255, 0, 0);"><b>AmMediaProcessor::instance()-&gt;addSession(this, callgroup)</b>;</span></div><div>  }</div><div>  else {</div><div>    DBG(&quot;no audio input and output set. &quot;</div><div>    &quot;Session will not be attached to MediaProcessor.\n&quot;);</div><div>  }</div><div>}</div></div><div><br/></div><div>AmMediaProcessor.cpp</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>void AmMediaProcessorThread::processAudio(unsigned long long ts)</div><div>{</div><div>  // receiving</div><div>  for(set&lt;AmMediaSession*&gt;::iterator it = sessions.begin();</div><div>      it != sessions.end(); it++)</div><div>  {</div><div>    if (<span style="color: rgb(255, 0, 0);"><b>(*it)-&gt;readStreams(ts, buffer)</b></span> &lt; 0)</div><div>      postRequest(new SchedRequest(AmMediaProcessor::ClearSession, *it));</div><div>  }</div><div><br/></div><div>  // sending</div><div>  for(set&lt;AmMediaSession*&gt;::iterator it = sessions.begin();</div><div>      it != sessions.end(); it++)</div><div>  {</div><div>    if ((*it)-&gt;writeStreams(ts, buffer) &lt; 0)</div><div>      postRequest(new SchedRequest(AmMediaProcessor::ClearSession, *it));</div><div>  }</div><div>}</div></div><div><br/></div><div>AmSession.cpp</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);">int AmSession::readStreams(unsigned long long ts, unsigned char *buffer)</span></div><div><span style="color: rgb(51, 51, 51);">{</span></div><div><span style="color: rgb(51, 51, 51);">  int res = 0;</span></div><div><span style="color: rgb(51, 51, 51);">  lockAudio();</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  AmRtpAudio *stream = RTPStream();</span></div><div><span style="color: rgb(51, 51, 51);">  unsigned int f_size = stream-&gt;getFrameSize();</span></div><div><span style="color: rgb(51, 51, 51);">  if (stream-&gt;checkInterval(ts)) {</span></div><div><span style="color: rgb(51, 51, 51);">    int got =</span> <span style="color: rgb(255, 0, 0);"><b>stream-&gt;get(ts, buffer, stream-&gt;getSampleRate(), f_size); //该函数处理完后，buffer中保存的是声音的PCM数据</b></span></div><div><span style="color: rgb(51, 51, 51);">    if (got &lt; 0) res = -1;</span></div><div><span style="color: rgb(51, 51, 51);">    if (got &gt; 0) {</span></div><div><span style="color: rgb(51, 51, 51);">      if (isDtmfDetectionEnabled())</span></div><div><span style="color: rgb(51, 51, 51);">        putDtmfAudio(buffer, got, ts);</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">     </span> if (input) res = input-&gt;put(ts, buffer, stream-&gt;getSampleRate(), got);</div><div><span style="color: rgb(51, 51, 51);">    }</span></div><div><span style="color: rgb(51, 51, 51);">  }</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  unlockAudio();</span></div><div><span style="color: rgb(51, 51, 51);">  return res;</span></div><div><span style="color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div><b>以下为stream-&gt;get的代码流程：</b></div><div>AmRtpAudio.cpp</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);">int AmRtpAudio::get(unsigned long long system_ts, unsigned char* buffer,</span></div><div><span style="color: rgb(51, 51, 51);">            int output_sample_rate, unsigned int nb_samples)</span></div><div><span style="color: rgb(51, 51, 51);">{</span></div><div><span style="color: rgb(51, 51, 51);">  if (!(receiving || getPassiveMode())) return 0; // like nothing received</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  int ret =</span> <span style="color: rgb(255, 0, 0);"><b>receive(system_ts); //从RtpStream缓存中获取下一个RTPPacket,并根据payload做解码处理，转成PCM。处理完成之后，数据被保存在一个AmPlayoutBuffer变量中。</b></span></div><div><span style="color: rgb(51, 51, 51);">  if(ret &lt; 0)</span></div><div><span style="color: rgb(51, 51, 51);">    return ret; // like nothing received?</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  if (!active) return 0;</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  unsigned int user_ts = scaleSystemTS(system_ts);</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  nb_samples = (unsigned int)((float)nb_samples * (float)getSampleRate()</span></div><div><span style="color: rgb(51, 51, 51);">                 / (float)output_sample_rate);</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);"> </span> u_int32_t size =</div><div>    PCM16_S2B(playout_buffer-&gt;read(user_ts,</div><div>                   (ShortSample*)((unsigned char*)samples),</div><div>                   nb_samples));</div><div><span style="color: rgb(51, 51, 51);">  if(output_sample_rate != getSampleRate()) {</span></div><div><span style="color: rgb(51, 51, 51);">    size = resampleOutput((unsigned char*)samples, size,</span></div><div><span style="color: rgb(51, 51, 51);">              getSampleRate(), output_sample_rate);</span></div><div><span style="color: rgb(51, 51, 51);">  }</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  memcpy(buffer,(unsigned char*)samples,size);</span></div><div><span style="color: rgb(51, 51, 51);"><br/></span></div><div><span style="color: rgb(51, 51, 51);">  return size;</span></div><div><span style="color: rgb(51, 51, 51);">}</span></div></div><div><br/></div><div><br/></div></span>
</div></body></html> 